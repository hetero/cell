#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <getopt.h>
#include <errno.h>
#include <stdint.h>
#include <math.h>
#include <assert.h>

#include "c63.h"
#include "tables.h"

// *** SPE PART ***
#include "types.h"
uint8_t read_tmp_array[256] __attribute__((aligned(128)));
VUC *read_tmp;

//VUC mask_dct1[16] = {
//      (VUC) {0x80, 0x80, 0x80, 0, 0x80, 0x80, 0x80, 1 ,0x80, 0x80, 0x80, 2, 0x80, 0x80, 0x80, 3},
//      (VUC) {0x80, 0x80, 0x80, 1, 0x80, 0x80, 0x80, 2, 0x80, 0x80, 0x80, 3, 0x80, 0x80, 0x80, 4},
//      (VUC) {0x80, 0x80, 0x80, 2, 0x80, 0x80, 0x80, 3, 0x80, 0x80, 0x80, 4, 0x80, 0x80, 0x80, 5},
//      (VUC) {0x80, 0x80, 0x80, 3, 0x80, 0x80, 0x80, 4, 0x80, 0x80, 0x80, 5, 0x80, 0x80, 0x80, 6},
//      (VUC) {0x80, 0x80, 0x80, 4, 0x80, 0x80, 0x80, 5, 0x80, 0x80, 0x80, 6, 0x80, 0x80, 0x80, 7},
//      (VUC) {0x80, 0x80, 0x80, 5, 0x80, 0x80, 0x80, 6, 0x80, 0x80, 0x80, 7, 0x80, 0x80, 0x80, 8},
//      (VUC) {0x80, 0x80, 0x80, 6, 0x80, 0x80, 0x80, 7, 0x80, 0x80, 0x80, 8, 0x80, 0x80, 0x80, 9},
//      (VUC) {0x80, 0x80, 0x80, 7, 0x80, 0x80, 0x80, 8, 0x80, 0x80, 0x80, 9, 0x80, 0x80, 0x80, 10},
//      (VUC) {0x80, 0x80, 0x80, 8, 0x80, 0x80, 0x80, 9, 0x80, 0x80, 0x80, 10, 0x80, 0x80, 0x80, 11},
//      (VUC) {0x80, 0x80, 0x80, 9, 0x80, 0x80, 0x80, 10, 0x80, 0x80, 0x80, 11, 0x80, 0x80, 0x80, 12},
//      (VUC) {0x80, 0x80, 0x80, 10, 0x80, 0x80, 0x80, 11, 0x80, 0x80, 0x80, 12, 0x80, 0x80, 0x80, 13},
//      (VUC) {0x80, 0x80, 0x80, 11, 0x80, 0x80, 0x80, 12, 0x80, 0x80, 0x80, 13, 0x80, 0x80, 0x80, 14},
//      (VUC) {0x80, 0x80, 0x80, 12, 0x80, 0x80, 0x80, 13, 0x80, 0x80, 0x80, 14, 0x80, 0x80, 0x80, 15},
//      (VUC) {0x80, 0x80, 0x80, 13, 0x80, 0x80, 0x80, 14, 0x80, 0x80, 0x80, 15, 0x80, 0x80, 0x80, 16},
//      (VUC) {0x80, 0x80, 0x80, 14, 0x80, 0x80, 0x80, 15, 0x80, 0x80, 0x80, 16, 0x80, 0x80, 0x80, 17},
//      (VUC) {0x80, 0x80, 0x80, 15, 0x80, 0x80, 0x80, 16, 0x80, 0x80, 0x80, 17, 0x80, 0x80, 0x80, 18},
//};
//
//VUC mask_dct2[16] = {
//      (VUC) {0x80, 0x80, 0x80, 4, 0x80, 0x80, 0x80, 5, 0x80, 0x80, 0x80, 6, 0x80, 0x80, 0x80, 7},
//      (VUC) {0x80, 0x80, 0x80, 5, 0x80, 0x80, 0x80, 6, 0x80, 0x80, 0x80, 7, 0x80, 0x80, 0x80, 8},
//      (VUC) {0x80, 0x80, 0x80, 6, 0x80, 0x80, 0x80, 7, 0x80, 0x80, 0x80, 8, 0x80, 0x80, 0x80, 9},
//      (VUC) {0x80, 0x80, 0x80, 7, 0x80, 0x80, 0x80, 8, 0x80, 0x80, 0x80, 9, 0x80, 0x80, 0x80, 10},
//      (VUC) {0x80, 0x80, 0x80, 8, 0x80, 0x80, 0x80, 9, 0x80, 0x80, 0x80, 10, 0x80, 0x80, 0x80, 11},
//      (VUC) {0x80, 0x80, 0x80, 9, 0x80, 0x80, 0x80, 10, 0x80, 0x80, 0x80, 11, 0x80, 0x80, 0x80, 12},
//      (VUC) {0x80, 0x80, 0x80, 10, 0x80, 0x80, 0x80, 11, 0x80, 0x80, 0x80, 12, 0x80, 0x80, 0x80, 13},
//      (VUC) {0x80, 0x80, 0x80, 11, 0x80, 0x80, 0x80, 12, 0x80, 0x80, 0x80, 13, 0x80, 0x80, 0x80, 14},
//      (VUC) {0x80, 0x80, 0x80, 12, 0x80, 0x80, 0x80, 13, 0x80, 0x80, 0x80, 14, 0x80, 0x80, 0x80, 15},
//      (VUC) {0x80, 0x80, 0x80, 13, 0x80, 0x80, 0x80, 14, 0x80, 0x80, 0x80, 15, 0x80, 0x80, 0x80, 16},
//      (VUC) {0x80, 0x80, 0x80, 14, 0x80, 0x80, 0x80, 15, 0x80, 0x80, 0x80, 16, 0x80, 0x80, 0x80, 17},
//      (VUC) {0x80, 0x80, 0x80, 15, 0x80, 0x80, 0x80, 16, 0x80, 0x80, 0x80, 17, 0x80, 0x80, 0x80, 18},
//      (VUC) {0x80, 0x80, 0x80, 16, 0x80, 0x80, 0x80, 17, 0x80, 0x80, 0x80, 18, 0x80, 0x80, 0x80, 19},
//      (VUC) {0x80, 0x80, 0x80, 17, 0x80, 0x80, 0x80, 18, 0x80, 0x80, 0x80, 19, 0x80, 0x80, 0x80, 20},
//      (VUC) {0x80, 0x80, 0x80, 18, 0x80, 0x80, 0x80, 19, 0x80, 0x80, 0x80, 20, 0x80, 0x80, 0x80, 21},
//      (VUC) {0x80, 0x80, 0x80, 19, 0x80, 0x80, 0x80, 20, 0x80, 0x80, 0x80, 21, 0x80, 0x80, 0x80, 22},
//};

VUC mask_dct1[16] = {
        (VUC) {0x1F, 0x1F, 0x1F, 0, 0x1F, 0x1F, 0x1F, 1 ,0x1F, 0x1F, 0x1F, 2, 0x1F, 0x1F, 0x1F, 3},
        (VUC) {0x1F, 0x1F, 0x1F, 1, 0x1F, 0x1F, 0x1F, 2, 0x1F, 0x1F, 0x1F, 3, 0x1F, 0x1F, 0x1F, 4},
        (VUC) {0x1F, 0x1F, 0x1F, 2, 0x1F, 0x1F, 0x1F, 3, 0x1F, 0x1F, 0x1F, 4, 0x1F, 0x1F, 0x1F, 5},
        (VUC) {0x1F, 0x1F, 0x1F, 3, 0x1F, 0x1F, 0x1F, 4, 0x1F, 0x1F, 0x1F, 5, 0x1F, 0x1F, 0x1F, 6},
        (VUC) {0x1F, 0x1F, 0x1F, 4, 0x1F, 0x1F, 0x1F, 5, 0x1F, 0x1F, 0x1F, 6, 0x1F, 0x1F, 0x1F, 7},
        (VUC) {0x1F, 0x1F, 0x1F, 5, 0x1F, 0x1F, 0x1F, 6, 0x1F, 0x1F, 0x1F, 7, 0x1F, 0x1F, 0x1F, 8},
        (VUC) {0x1F, 0x1F, 0x1F, 6, 0x1F, 0x1F, 0x1F, 7, 0x1F, 0x1F, 0x1F, 8, 0x1F, 0x1F, 0x1F, 9},
        (VUC) {0x1F, 0x1F, 0x1F, 7, 0x1F, 0x1F, 0x1F, 8, 0x1F, 0x1F, 0x1F, 9, 0x1F, 0x1F, 0x1F, 10},
        (VUC) {0x1F, 0x1F, 0x1F, 8, 0x1F, 0x1F, 0x1F, 9, 0x1F, 0x1F, 0x1F, 10, 0x1F, 0x1F, 0x1F, 11},
        (VUC) {0x1F, 0x1F, 0x1F, 9, 0x1F, 0x1F, 0x1F, 10, 0x1F, 0x1F, 0x1F, 11, 0x1F, 0x1F, 0x1F, 12},
        (VUC) {0x1F, 0x1F, 0x1F, 10, 0x1F, 0x1F, 0x1F, 11, 0x1F, 0x1F, 0x1F, 12, 0x1F, 0x1F, 0x1F, 13},
        (VUC) {0x1F, 0x1F, 0x1F, 11, 0x1F, 0x1F, 0x1F, 12, 0x1F, 0x1F, 0x1F, 13, 0x1F, 0x1F, 0x1F, 14},
        (VUC) {0x1F, 0x1F, 0x1F, 12, 0x1F, 0x1F, 0x1F, 13, 0x1F, 0x1F, 0x1F, 14, 0x1F, 0x1F, 0x1F, 15},
        (VUC) {0x1F, 0x1F, 0x1F, 13, 0x1F, 0x1F, 0x1F, 14, 0x1F, 0x1F, 0x1F, 15, 0x1F, 0x1F, 0x1F, 16},
        (VUC) {0x1F, 0x1F, 0x1F, 14, 0x1F, 0x1F, 0x1F, 15, 0x1F, 0x1F, 0x1F, 16, 0x1F, 0x1F, 0x1F, 17},
        (VUC) {0x1F, 0x1F, 0x1F, 15, 0x1F, 0x1F, 0x1F, 16, 0x1F, 0x1F, 0x1F, 17, 0x1F, 0x1F, 0x1F, 18}
};

VUC mask_dct2[16] = {
        (VUC) {0x1F, 0x1F, 0x1F, 4, 0x1F, 0x1F, 0x1F, 5, 0x1F, 0x1F, 0x1F, 6, 0x1F, 0x1F, 0x1F, 7},
        (VUC) {0x1F, 0x1F, 0x1F, 5, 0x1F, 0x1F, 0x1F, 6, 0x1F, 0x1F, 0x1F, 7, 0x1F, 0x1F, 0x1F, 8},
        (VUC) {0x1F, 0x1F, 0x1F, 6, 0x1F, 0x1F, 0x1F, 7, 0x1F, 0x1F, 0x1F, 8, 0x1F, 0x1F, 0x1F, 9},
        (VUC) {0x1F, 0x1F, 0x1F, 7, 0x1F, 0x1F, 0x1F, 8, 0x1F, 0x1F, 0x1F, 9, 0x1F, 0x1F, 0x1F, 10},
        (VUC) {0x1F, 0x1F, 0x1F, 8, 0x1F, 0x1F, 0x1F, 9, 0x1F, 0x1F, 0x1F, 10, 0x1F, 0x1F, 0x1F, 11},
        (VUC) {0x1F, 0x1F, 0x1F, 9, 0x1F, 0x1F, 0x1F, 10, 0x1F, 0x1F, 0x1F, 11, 0x1F, 0x1F, 0x1F, 12},
        (VUC) {0x1F, 0x1F, 0x1F, 10, 0x1F, 0x1F, 0x1F, 11, 0x1F, 0x1F, 0x1F, 12, 0x1F, 0x1F, 0x1F, 13},
        (VUC) {0x1F, 0x1F, 0x1F, 11, 0x1F, 0x1F, 0x1F, 12, 0x1F, 0x1F, 0x1F, 13, 0x1F, 0x1F, 0x1F, 14},
        (VUC) {0x1F, 0x1F, 0x1F, 12, 0x1F, 0x1F, 0x1F, 13, 0x1F, 0x1F, 0x1F, 14, 0x1F, 0x1F, 0x1F, 15},
        (VUC) {0x1F, 0x1F, 0x1F, 13, 0x1F, 0x1F, 0x1F, 14, 0x1F, 0x1F, 0x1F, 15, 0x1F, 0x1F, 0x1F, 16},
        (VUC) {0x1F, 0x1F, 0x1F, 14, 0x1F, 0x1F, 0x1F, 15, 0x1F, 0x1F, 0x1F, 16, 0x1F, 0x1F, 0x1F, 17},
        (VUC) {0x1F, 0x1F, 0x1F, 15, 0x1F, 0x1F, 0x1F, 16, 0x1F, 0x1F, 0x1F, 17, 0x1F, 0x1F, 0x1F, 18},
        (VUC) {0x1F, 0x1F, 0x1F, 16, 0x1F, 0x1F, 0x1F, 17, 0x1F, 0x1F, 0x1F, 18, 0x1F, 0x1F, 0x1F, 19},
        (VUC) {0x1F, 0x1F, 0x1F, 17, 0x1F, 0x1F, 0x1F, 18, 0x1F, 0x1F, 0x1F, 19, 0x1F, 0x1F, 0x1F, 20},
        (VUC) {0x1F, 0x1F, 0x1F, 18, 0x1F, 0x1F, 0x1F, 19, 0x1F, 0x1F, 0x1F, 20, 0x1F, 0x1F, 0x1F, 21},
        (VUC) {0x1F, 0x1F, 0x1F, 19, 0x1F, 0x1F, 0x1F, 20, 0x1F, 0x1F, 0x1F, 21, 0x1F, 0x1F, 0x1F, 22}
};

// ****************

void dequantize_idct_row(int16_t *in_data, uint8_t *prediction, int w, int h, int y,
			 uint8_t *out_data, uint8_t *quantization)
{
    int x;

    int16_t block[8*8];

    /* Perform the dequantization and iDCT */
    for(x = 0; x < w; x += 8)
    {
        int i,j;
        dequant_idct_block_8x8(in_data+(x*8), block, quantization);


        for (i=0; i<8; ++i)
            for (j=0; j<8; ++j)
            {
                /* Add prediction block. Note: DCT is not precise - Clamp to legal values */
                int16_t tmp = block[i*8+j] + (int16_t)prediction[i*w+j+x];
                if (tmp < 0)
                    tmp = 0;
                else if (tmp > 255)
                    tmp = 255;

                out_data[i*w+j+x] = tmp;
            }
    }
}

void dequantize_idct(int16_t *in_data, uint8_t *prediction, uint32_t width, uint32_t height,
			 uint8_t *out_data, uint8_t *quantization)
{
    int y;
    for (y=0; y<height; y+=8)
    {
        dequantize_idct_row(in_data+y*width, prediction+y*width, width, height, y, out_data+y*width, quantization);
    }
}

void read_row(ULL src, int size, int offset) {
//    int tag = 1;

        // ***
        read_tmp = (VUC *) read_tmp_array;
        // ***
    int read_size = size + offset;
    read_size += (16 - (read_size%16)) % 16;

//    spu_mfcdma64(read_tmp, mfc_ea2h(src), mfc_ea2l(src),
//            (read_size) * sizeof(uint8_t), tag, MFC_GET_CMD);
//    spu_writech(MFC_WrTagMask, 1 << tag);
//    spu_mfcstat(MFC_TAG_UPDATE_ALL);

    memcpy((void *) read_tmp, (void *) (unsigned long) src, read_size);
}

void dct_quantize_row(uint8_t *in_data, uint8_t *prediction, int w, int h,
        int16_t *out_data, uint8_t *quantization)
{
    int x;

    VSI block[2 * 8];
    VSI tmp[2];
    VUC *act_block;

#ifdef DCT_QUANTIZE_ROW_DEBUG
    int block_tmp[8*8];
#endif

    for(x = 0; x < w; x += 8)
    {
        int i;
        for (i = 0; i < 8; ++i)
        {
            ULL src = (ULL) (UL) &in_data[i * w + x];
            int offset = src % 128;
            src -= offset;
            read_row(src, 8, offset);

#ifdef DCT_QUANTIZE_ROW_DEBUG
            int j;
            printf("in_data: ");
            for (j = 0; j < 8; ++j)
            {
                printf("%d ", in_data[i * w + x + j]);
            }
            printf("\n");

            printf("read_row: ");
            uint8_t *ble = (uint8_t *)read_tmp;
            for (j = 0; j < offset + 8; ++j)
            {
                printf("%d ", ble[j]);
            }
            printf("\n");
#endif

            // HACK
            ((uint8_t *)&read_tmp[offset / 16 + 1])[15] = 0;
            // ****
            act_block = (VUC *)&block[i * 2];
            *act_block = vec_perm(read_tmp[offset / 16],
                            read_tmp[offset / 16 + 1], mask_dct1[offset % 16]);
            act_block = (VUC *)&block[i * 2 + 1];
            *act_block = vec_perm(read_tmp[offset / 16],
                            read_tmp[offset / 16 + 1], mask_dct2[offset % 16]);

#ifdef DCT_QUANTIZE_ROW_DEBUG 
            printf("blocks: ");
            ble = (uint8_t *)&block[i * 2];
            for (j = 0; j < 16; ++j)
            {
                printf("%d ", ble[j]);
            }
            printf("\n");
            ble = (uint8_t *)&block[i * 2 + 1];
            for (j = 0; j < 16; ++j)
            {
                printf("%d ", ble[j]);
            }
            printf("\n");
            printf("blocks as ints: ");
            int *ble2 = (int *)&block[i * 2];
            for (j = 0; j < 4; ++j)
                printf("%d ", ble2[j]);
            printf("\n");
            ble2 = (int *)&block[i * 2 + 1];
            for (j = 0; j < 4; ++j)
                printf("%d ", ble2[j]);
            printf("\n");
#endif

            src = (ULL) (UL) &prediction[i * w + x];
            offset = src % 128;
            src -= offset;
            read_row(src, 8, offset);
            // HACK
            ((uint8_t *)&read_tmp[offset / 16 + 1])[15] = 0;
            // ****
            act_block = (VUC *)&tmp[0];
            *act_block = vec_perm(read_tmp[offset / 16],
                    read_tmp[offset / 16 + 1], mask_dct1[offset % 16]);
            act_block = (VUC *)&tmp[1];
            *act_block = vec_perm(read_tmp[offset / 16],
                    read_tmp[offset / 16 + 1], mask_dct2[offset % 16]);
            block[i * 2] = vec_sub(block[i * 2], tmp[0]);
            block[i * 2 + 1] = vec_sub(block[i * 2 + 1], tmp[1]);

#ifdef DCT_QUANTIZE_ROW_DEBUG
            printf("blocks as ints after sub: ");
            ble2 = (int *)&block[i * 2];
            for (j = 0; j < 4; ++j)
                printf("%d ", ble2[j]);
            printf("\n");
            ble2 = (int *)&block[i * 2 + 1];
            for (j = 0; j < 4; ++j)
                printf("%d ", ble2[j]);
            printf("\n");
        
            int k;
            for (k=0; k<8; ++k)
                block_tmp[i*8+k] = ((int)in_data[i*w+k+x] - (int)prediction[i*w+k+x]);
#endif
        }

#ifdef DCT_QUANTIZE_ROW_DEBUG
        printf("normal block:\n");
        for (i = 0; i < 64; ++i)
        {
            printf("%d ", block_tmp[i]);
        }
        printf("\n");
        printf("vec block:\n");
        for (i = 0; i < 64; ++i)
            printf("%d ", ((int *)&block[i / 4])[i % 4]);
        printf("\n");
#endif

        dct_quant_block_8x8((int *)block, out_data+(x*8), quantization);
    }
}
/*
void dct_quantize_row(uint8_t *in_data, uint8_t *prediction, int w, int h,
        int16_t *out_data, uint8_t *quantization)
{
    int x;

    int16_t block[8*8];

    for(x = 0; x < w; x += 8)
    {
        int i,j;
        for (i=0; i<8; ++i)
            for (j=0; j<8; ++j)
                block[i*8+j] = ((int16_t)in_data[i*w+j+x] - prediction[i*w+j+x]);

        dct_quant_block_8x8(block, out_data+(x*8), quantization);
    }
}
*/
void dct_quantize(uint8_t *in_data, uint8_t *prediction,
        uint32_t width, uint32_t height,
        int16_t *out_data, uint8_t *quantization)
{
    int y;
    for (y=0; y<height; y+=8)
    {
        dct_quantize_row(in_data+y*width, prediction+y*width, width, height, out_data+y*width, quantization);
    }
}

void destroy_frame(struct frame *f)
{
    if (!f) // First frame
        return;

    free(f->recons->Y);
    free(f->recons->U);
    free(f->recons->V);
    free(f->recons);

    free(f->residuals->Ydct);
    free(f->residuals->Udct);
    free(f->residuals->Vdct);
    free(f->residuals);

    free(f->predicted->Y);
    free(f->predicted->U);
    free(f->predicted->V);
    free(f->predicted);

    free(f->mbs[0]);
    free(f->mbs[1]);
    free(f->mbs[2]);

    free(f);
}

struct frame* create_frame(struct c63_common *cm, yuv_t *image)
{
    struct frame *f = malloc(sizeof(struct frame));

    f->orig = image;

    f->recons = malloc(sizeof(yuv_t));
    f->recons->Y = malloc(cm->ypw * cm->yph);
    f->recons->U = malloc(cm->upw * cm->uph);
    f->recons->V = malloc(cm->vpw * cm->vph);

    f->predicted = malloc(sizeof(yuv_t));
    f->predicted->Y = malloc(cm->ypw * cm->yph);
    f->predicted->U = malloc(cm->upw * cm->uph);
    f->predicted->V = malloc(cm->vpw * cm->vph);

    memset(f->predicted->Y, 0x80, cm->ypw * cm->yph);
    memset(f->predicted->U, 0x80, cm->upw * cm->uph);
    memset(f->predicted->V, 0x80, cm->vpw * cm->vph);

    f->residuals = malloc(sizeof(dct_t));
    f->residuals->Ydct = malloc(cm->ypw * cm->yph * sizeof(int16_t));
    f->residuals->Udct = malloc(cm->upw * cm->uph * sizeof(int16_t));
    f->residuals->Vdct = malloc(cm->vpw * cm->vph * sizeof(int16_t));

    memset(f->residuals->Ydct, 0x80, cm->ypw * cm->yph * sizeof(int16_t));
    memset(f->residuals->Udct, 0x80, cm->upw * cm->uph * sizeof(int16_t));
    memset(f->residuals->Vdct, 0x80, cm->vpw * cm->vph * sizeof(int16_t));

    f->mbs[0] = calloc(cm->ypw * cm->yph, sizeof(struct macroblock));
    f->mbs[1] = calloc(cm->upw * cm->uph, sizeof(struct macroblock));
    f->mbs[2] = calloc(cm->vpw * cm->vph, sizeof(struct macroblock));

    return f;
}

void dump_image(yuv_t *image, int w, int h, FILE *fp)
{
    fwrite(image->Y, 1, w*h, fp);
    fwrite(image->U, 1, w*h/4, fp);
    fwrite(image->V, 1, w*h/4, fp);
}

